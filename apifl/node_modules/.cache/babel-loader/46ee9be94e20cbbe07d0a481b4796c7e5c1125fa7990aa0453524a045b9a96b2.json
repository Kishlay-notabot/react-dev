{"ast":null,"code":"// src/query.ts\nimport { noop, replaceData, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = class extends Removable {\n  constructor(config) {\n    super();\n    this.#abortSignalConsumed = false;\n    this.#defaultOptions = config.defaultOptions;\n    this.#setOptions(config.options);\n    this.#observers = [];\n    this.#cache = config.cache;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.#initialState = config.state || getDefaultState(this.options);\n    this.state = this.#initialState;\n    this.scheduleGc();\n  }\n  #initialState;\n  #revertState;\n  #cache;\n  #promise;\n  #retryer;\n  #observers;\n  #defaultOptions;\n  #abortSignalConsumed;\n  get meta() {\n    return this.options.meta;\n  }\n  #setOptions(options) {\n    this.options = {\n      ...this.#defaultOptions,\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === \"idle\") {\n      this.#cache.remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    this.#dispatch({\n      data,\n      type: \"success\",\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    this.#dispatch({\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    const promise = this.#promise;\n    this.#retryer?.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(this.#initialState);\n  }\n  isActive() {\n    return this.#observers.some(observer => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.#observers.some(observer => observer.getCurrentResult().isStale);\n  }\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    const observer = this.#observers.find(x => x.shouldFetchOnWindowFocus());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  onOnline() {\n    const observer = this.#observers.find(x => x.shouldFetchOnReconnect());\n    observer?.refetch({\n      cancelRefetch: false\n    });\n    this.#retryer?.continue();\n  }\n  addObserver(observer) {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer);\n      this.clearGcTimeout();\n      this.#cache.notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter(x => x !== observer);\n      if (!this.#observers.length) {\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.#retryer.cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      this.#cache.notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.#observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({\n        type: \"invalidate\"\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (this.#promise) {\n        this.#retryer?.continueRetry();\n        return this.#promise;\n      }\n    }\n    if (options) {\n      this.#setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.#setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(`As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`);\n      }\n    }\n    const abortController = new AbortController();\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true;\n          return abortController.signal;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext);\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(new Error(`Missing queryFn: '${this.options.queryHash}'`));\n      }\n      this.#abortSignalConsumed = false;\n      if (this.options.persister) {\n        return this.options.persister(this.options.queryFn, queryFnContext, this);\n      }\n      return this.options.queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    this.options.behavior?.onFetch(context, this);\n    this.#revertState = this.state;\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== context.fetchOptions?.meta) {\n      this.#dispatch({\n        type: \"fetch\",\n        meta: context.fetchOptions?.meta\n      });\n    }\n    const onError = error => {\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        this.#cache.config.onError?.(error, this);\n        this.#cache.config.onSettled?.(this.state.data, error, this);\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    this.#retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: data => {\n        if (typeof data === \"undefined\") {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(`Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`);\n          }\n          onError(new Error(`${this.queryHash} data is undefined`));\n          return;\n        }\n        this.setData(data);\n        this.#cache.config.onSuccess?.(data, this);\n        this.#cache.config.onSettled?.(data, this.state.error, this);\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        this.#dispatch({\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        this.#dispatch({\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.#promise = this.#retryer.promise;\n    return this.#promise;\n  }\n  #dispatch(action) {\n    const reducer = state => {\n      switch (action.type) {\n        case \"failed\":\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error\n          };\n        case \"pause\":\n          return {\n            ...state,\n            fetchStatus: \"paused\"\n          };\n        case \"continue\":\n          return {\n            ...state,\n            fetchStatus: \"fetching\"\n          };\n        case \"fetch\":\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode) ? \"fetching\" : \"paused\",\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: \"pending\"\n            })\n          };\n        case \"success\":\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: \"success\",\n            ...(!action.manual && {\n              fetchStatus: \"idle\",\n              fetchFailureCount: 0,\n              fetchFailureReason: null\n            })\n          };\n        case \"error\":\n          const error = action.error;\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return {\n              ...this.#revertState,\n              fetchStatus: \"idle\"\n            };\n          }\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: \"idle\",\n            status: \"error\"\n          };\n        case \"invalidate\":\n          return {\n            ...state,\n            isInvalidated: true\n          };\n        case \"setState\":\n          return {\n            ...state,\n            ...action.state\n          };\n      }\n    };\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.#observers.forEach(observer => {\n        observer.onQueryUpdate();\n      });\n      this.#cache.notify({\n        query: this,\n        type: \"updated\",\n        action\n      });\n    });\n  }\n};\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = typeof data !== \"undefined\";\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query };","map":{"version":3,"names":["noop","replaceData","timeUntilStale","notifyManager","canFetch","createRetryer","isCancelledError","Removable","Query","constructor","config","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","queryKey","queryHash","initialState","state","getDefaultState","scheduleGc","revertState","promise","retryer","meta","#setOptions","updateGcTime","gcTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","onFocus","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","continueRetry","queryFn","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","queryFnContext","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","Error","persister","context","behavior","onFetch","fetchMeta","onError","onSettled","isFetchingOptimistic","fn","abort","bind","onSuccess","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","#dispatch","action","reducer","fetchFailureCount","fetchFailureReason","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["C:\\Users\\kishl\\Downloads\\code_oin\\node_modules\\@tanstack\\query-core\\src\\query.ts"],"sourcesContent":["import { noop, replaceData, timeUntilStale } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #promise?: Promise<TData>\n  #retryer?: Retryer<TData>\n  #observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.#setOptions(config.options)\n    this.#observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  #setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.#observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter((x) => x !== observer)\n\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.#observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({ silent: true })\n      } else if (this.#promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.#setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.#setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: Omit<QueryFunctionContext<TQueryKey>, 'signal'> = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`),\n        )\n      }\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: Omit<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.#promise = this.#retryer.promise\n\n    return this.#promise\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'pending',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}