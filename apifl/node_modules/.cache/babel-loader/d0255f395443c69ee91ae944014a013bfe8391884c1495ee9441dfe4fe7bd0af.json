{"ast":null,"code":"\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport { QueriesObserver, QueryObserver, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport { ensurePreventErrorBoundaryRetry, getHasError, useClearResetErrorBoundary } from \"./errorBoundaryUtils.js\";\nimport { ensureStaleTime, fetchOptimistic, shouldSuspend, willFetch } from \"./suspense.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(() => queries.map(opts => {\n    const defaultedOptions = client.defaultQueryOptions(opts);\n    defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n    return defaultedOptions;\n  }), [queries, client, isRestoring]);\n  defaultedQueries.forEach(query => {\n    ensureStaleTime(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(() => new QueriesObserver(client, defaultedQueries, options));\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(defaultedQueries);\n  React.useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    observer.setQueries(defaultedQueries, options, {\n      listeners: false\n    });\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => shouldSuspend(defaultedQueries[index], result));\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    observer.setQueries(defaultedQueries, options, {\n      listeners: false\n    });\n    throw Promise.all(suspensePromises);\n  }\n  const observerQueries = observer.getQueries();\n  const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedQueries[index]?.throwOnError ?? false,\n    query: observerQueries[index]\n  }));\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport { useQueries };","map":{"version":3,"names":["React","QueriesObserver","QueryObserver","notifyManager","useQueryClient","useIsRestoring","useQueryErrorResetBoundary","ensurePreventErrorBoundaryRetry","getHasError","useClearResetErrorBoundary","ensureStaleTime","fetchOptimistic","shouldSuspend","willFetch","useQueries","queries","options","queryClient","client","isRestoring","errorResetBoundary","defaultedQueries","useMemo","map","opts","defaultedOptions","defaultQueryOptions","_optimisticResults","forEach","query","observer","useState","optimisticResult","getCombinedResult","trackResult","getOptimisticResult","useSyncExternalStore","useCallback","onStoreChange","subscribe","batchCalls","getCurrentResult","useEffect","setQueries","listeners","shouldAtLeastOneSuspend","some","result","index","suspensePromises","flatMap","queryObserver","length","Promise","all","observerQueries","getQueries","firstSingleResultWhichShouldThrow","find","throwOnError","error"],"sources":["C:\\Users\\kishl\\Downloads\\code_oin\\node_modules\\@tanstack\\react-query\\src\\useQueries.ts"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './isRestoring'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureStaleTime,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type { UseQueryOptions, UseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'suspense'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\ntype GetOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<infer TQueryFnData, infer TQueryKey>\n                    select: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<\n                        infer TQueryFnData,\n                        infer TQueryKey\n                      >\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryOptionsForUseQueries<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseQueryOptionsForUseQueries\n\ntype GetResults<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?: QueryFunction<unknown, any>\n                    select: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryResult<\n                    TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?: QueryFunction<infer TQueryFnData, any>\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetOptions<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesOptions<\n            [...Tail],\n            [...Result, GetOptions<Head>],\n            [...Depth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  Result extends Array<any> = [],\n  Depth extends ReadonlyArray<number> = [],\n> = Depth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...Result, GetResults<Head>]\n      : T extends [infer Head, ...infer Tail]\n        ? QueriesResults<\n            [...Tail],\n            [...Result, GetResults<Head>],\n            [...Depth, 1]\n          >\n        : T extends Array<\n              UseQueryOptionsForUseQueries<\n                infer TQueryFnData,\n                infer TError,\n                infer TData,\n                any\n              >\n            >\n          ? // Dynamic-size (homogenous) UseQueryOptions array: map directly to array of results\n            Array<\n              UseQueryResult<\n                unknown extends TData ? TQueryFnData : TData,\n                unknown extends TError ? DefaultError : TError\n              >\n            >\n          : // Fallback\n            Array<UseQueryResult>\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries: readonly [...QueriesOptions<T>]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(opts)\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureStaleTime(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(defaultedQueries)\n\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        isRestoring\n          ? () => undefined\n          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer, isRestoring],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n      {\n        listeners: false,\n      },\n    )\n    throw Promise.all(suspensePromises)\n  }\n  const observerQueries = observer.getQueries()\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) =>\n      getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: defaultedQueries[index]?.throwOnError ?? false,\n        query: observerQueries[index]!,\n      }),\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}